<!DOCTYPE html>
<html>

<head>
  <title>311 Response Times</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet">
  <link href='https://api.mapbox.com/mapbox-gl-js/v0.40.0/mapbox-gl.css' rel='stylesheet' />
  <link rel="stylesheet" href="./style.css"></link>
</head>

<body>
  <header>
    <h1>311 Resolution Times in NYC</h1>
  </header>
  <div id="app">
    <svg width="960" height="960" font-family="sans-serif" font-size="10" text-anchor="middle"></svg>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>

      var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

      var format = d3.format(",d");

      var color = d3.scaleOrdinal(d3.schemeCategory20c);

      var pack = d3.pack()
        .size([width, height])
        .padding(1.5);

      //code to use when ready to parse actual data. this calculates the time to resolve each issue in a row in the dataset and sets the time to the 'value for that date'   
      d3.csv("311_Service_Requests_from_2010_to_Present.csv", function (d) {
        let createdDate = new Date(d["Created Date"])
        let closedDate = new Date(d["Closed Date"])
        let resolutionTime = (closedDate - createdDate)

        d.value = resolutionTime
        //convert the milliseconds elapsed between issue open/close into string with days and minutes
        function msToTime(duration) {
          var minutes = parseInt((duration / (1000 * 60)) % 60)
            , hours = parseInt((duration / (1000 * 60 * 60)) % 24);

          hours = (hours < 10) ? "0" + hours : hours;
          minutes = (minutes < 10) ? "0" + minutes : minutes;
          return hours + " hour(s) " + minutes + " minutes"
        }

        d.durationText = msToTime(resolutionTime)

        if (d.value) return d;
      }, function (error, classes) {
        if (error) throw error;

        var root = d3.hierarchy({ children: classes })
          .sum(function (d) { return d.value; })
          .each(function (d) {
            if (Descriptor = d.data["Descriptor"]) {
              d.descriptor = d.data["Descriptor"]
            }
          });

        var node = svg.selectAll(".node")
          .data(pack(root).leaves())
          .enter().append("g")
          .attr("class", "node")
          .attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; });

        node.append("circle")
          .attr("descriptor", function (d) {
            return d.descriptor;
          })
          .attr("r", function (d) { return d.r; })
          //d.descriptor is the description of the type of complaint, all complaints with the same descriptor will have the same color
          .style("fill", function (d) { return color(d.descriptor); });

        node.append("clipPath")
          .attr("id", function (d) { return "clip-" + d.descriptor; })
          .append("use")
          .attr("href", function (d) { return "#" + d.descriptor; });

        node.append("text")
          .attr("clip-path", function (d) { return "url(#clip-" + d.descriptor + ")"; })
          .selectAll("tspan")
          .data(function (d) { return d.descriptor.split(/(?=[A-Z][^A-Z])/g); })
          .enter().append("tspan")
          .attr("x", 0)
          .attr("y", function (d, i, nodes) { return 13 + (i - nodes.length / 2 - 0.5) * 10; })
          .text(function (d) { return d; });

        node.append("title")
          .text(function (d) {
            //adds pop up for duration when hovering over bubble
            return d.data["Borough"] + "\n" + (d.data.durationText);
          });
      });

    </script>

  </div>

</body>

</html>